##Domain file format for hybriddomain project
##Version 1 domain (.dom)

# Domain geometry
##!  uint8: 254
##!  uint8: file format version major
##!  uint8: file format version minor

##!  3*float64: StartTime, FinishTime, Initial timestep
##!  float64: save interval
##!  3* float64: dx, dy, dz
##!  int32 dimension Db (can be 1,2 or 3) 
##!  int32 Cell Size
##!  int32 Halo Size
##!  int32 Solver number (0=Euler, 1= RK4, etc,  see solver.h)
##!  2* float64: Solver absolute and relative tolerance

##!  1*int: problem type (0 - ordinary, 1 - delay)
###  if problem type == 1
##!  1*int number of delays N_D
##!  N_D*float64 delay values
##!  uint64 S_N number of states that can be stored in memory 
###  endif


### blocks 
##!  int32: number of blocks N_B
### following are N_B 1-2-3d blocks one by one
### BEGINNING OF BLOCK 
##!  int32 computation node
##!  int32 computation device type
##!  int32 computation device number
##!  Db*int32: offset x, y, z (in number of grid steps) 
##!  Db*int32: xc, yc, and zc number of grid steps in this block, total=xc*yc*zc
### properties of every volume
##!  total*uint16: init function number
##!  total*uint16: computation function number 
### END OF BLOCK

### Interconnects 
##!  int32: number of interconnects N_I
### following are N_I interconnects one by one
### BEGINNING OF IC
##!  int32 dimension I_d (can be 0,1,2)
##!  I_d*int32 interconnect length
##!  int32 source block 
##!  int32 destination block
##!  int32 source side (0-5)
##!  int32 destination side (0-5)
##!  I_d*int32 source offset 
##!  I_d*int32 destination offset
### END OF IC

### Plot config
##!  int32: number of plots N_P
##!  N_P * float64 interval values
### End of plot config

===============================================================================
## State file format for draw(*.dbin)
##!  uint8: 253
##!  uint8: file format version major
##!  uint8: file format version minor

##!  float64 current time 
##!  float64 current timestep
###  following is the N_B  blocks one by one
###  BEGINNING OF THE BLOCK##!   
##!   total*cellsize*float64: state 
###  END OF THE BLOCK


===============================================================================
## State file format for load (ODE) (*.lbin)
##!  uint8: 253
##!  uint8: file format version major
##!  uint8: file format version minor

##!  float64 current time 
##!  float64 current timestep
###  following is the N_B  blocks one by one
###  BEGINNING OF THE BLOCK##!   
##!  total*cellsize*float64: state 
###  END OF THE BLOCK


===============================================================================
## State file format for load (DDE) (*.lbin)
##!  uint8: 253
##!  uint8: file format version major
##!  uint8: file format version minor

##!  float64 current time 
##!  float64 current timestep

##!  int32 currentStateNumber
##!  int32*delaycount delay state indices
##!  number of useful states*float64 state timestamps
###  following is the N_B  blocks one by one
###  BEGINNING OF THE BLOCK 
##!  number of useful states*state size*float64
###  END OF THE BLOCK




###  following is the N_B  blocks one by one
###  BEGINNING OF THE BLOCK##!   
##!   total*cellsize*float64: state 
###  END OF THE BLOCK



Порядок функций

0: центральная функция
Далее угловые функции
далее в порядке границ 0-1-2-3 для каждой границы 
1. условие по умолчанию
2-н условия пользователя в том порядке 

1d:
гало = 1
[1 0 0 0 0 0 0 0 0 2]

гало = 2
[1 2 0 0 0 0 0 0 3 4]

2d, ось x по горизонтали, ось y по вертикали
гало = 1
[[1 5 5 5 6 5 6 6 6  2]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [9 0 0 0 0 0 0 0 0 10]
 [8 0 0 0 0 0 0 0 0 10]
 [8 0 0 0 0 0 0 0 0 10]
 [8 0 0 0 0 0 0 0 0 10]
 [3 7 7 7 7 7 7 7 7 4]

гало = 2
[[ 1  2  3  3  3  3  3  3  4  5]
 [ 6  7  8  8  8  8  8  8  9 10]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [11 12  0  0  0  0  0  0 13 14]
 [15 16 17 17 17 17 17 17 18 19]
 [20 21 22 22 22 22 22 22 23 24]]

Краевое условие типа Неймана переписывает касающиеся его клетки (длина задана пользователем, ширина равна гало)
Если это условие накладывается на угол, то угол не переписывается
Если одно и то же краевое условие Неймана встречается несколько раз в границах, то каждый экземпляр имеет свой собственный номер
и свою функцию, т.к. функции на разных границах обычно  различаются.  

Краевое условие типа Дирихле на всем своем протяжении переписывает одну и ту же функцию вычисления производной. 
Для констант это просто возврат нуля, для функций, зависящих от времени - вычисленная пользователем произовдная.
Все регионы, соответствующие одному условию Дирихле, помечаются одной функцией в том порядке, в котором 
 
Краевое условие типа Дирихле требует изменения начального условия в касающихся его клетках.


Итоговый порядок функций на примере гало=1:
0..8 - Нейманы по умолчанию



 
 Каждая вычислительная функция принимает на вход список границ блока double**
 в том порядке, в котором появились входящие в этот блок интерконнекты.
  
