\documentclass[a4paper]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts,amssymb,amscd,amsmath}
\usepackage[left=3cm, right=2cm, top=2cm, bottom=2cm]{geometry}

\begin{document}
\begin{center}
{\Huge \bf Описание генератора функций}
\end{center}

\large
\section*{\LARGE Введение. Текущие возможности и актуальные файлы}
Сейчас ($07.08.15$)  генератор умеет генерировать функции в таких случаях:
\begin{itemize}
\item одномерный случай с соединениями, ни в одном уравнении нет про\-из\-вод\-ных порядка выше второго;
\item двумерный случай с соединениями, ни в одном уравнении не со\-дер\-жит\-ся смешанных производных и производных порядка выше второго;
\item двумерный случай, в уравнениях могут содержаться смешанные про\-из\-вод\-ные второго порядка, ни в одном уравнении нет производных порядка выше второго --- правильно может быть обработана только ситуация, когда нет соединяющихся блоков (т.е. при генерировании функций не приходится приближать смешанные производные в мес\-тах соединений).
\item трехмерный случай с соединениями,  ни в одном уравнении не со\-дер\-жит\-ся смешанных производных и производных порядка выше второго.
\end{itemize}

Для генерирования функций используются файлы, находящиеся в пап\-ке domainmodel:
\begin{enumerate}
\item  customOfficer.py; \label{i1}
\item equationParser.py; \label{i2}
\item newFuncGenerator.py; \label{i3}
\item  rhsCodeGenerator.py; \label{i4}
\item derivCodeGenerator.py; \label{i5}
\item someFuncs.py; \label{i6}
\item DerivHandler.py. \label{i7}
\end{enumerate}

Файлы \ref{i6} и \ref{i7} используются для генерации, но функции, лежащие в них, могут использоваться и для других целей. Из файла \ref{i6} для генерации используются функции {\bf NewtonBinomCoefficient()}, {\bf generateCodeForMathFunction()}, {\bf determineNameOfBoundary()}, {\bf RectSquare()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Функции {\bf factorial()} и {\bf getCellCountAlongLine()} из этого же файла используются функциями {\bf NewtonBinomCoefficient()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Файл \ref{i7} содержит функцию, которая находит порядок старшей про\-из\-вод\-ной.

\newpage
\section{\LARGE{Описание основных файлов}}
\subsection{\Large Файл customOfficer.py и проверка входных данных}
Файл \ref{i1} (customOfficer.py) создан для проверки некоторых введенных в *.json данных на корректность перед запуском генерации функций. Этот файл содержит класс {\bf Reviewer}, который связан с внешним миром методом {\bf ReviewInput()}. В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} создается экземпляр класса {\bf Reviewer} и вызывается его метод {\bf ReviewInput()}. Этот метод проверит правильность введения бло\-ков и параметров.

Основные методы класса {\bf Reviewer}:
\begin{itemize}
\item {\bf ReviewParameters()}. Проверит, нет ли в списке параметров "Pa\-rams" повторяющихся имен; совпадает ли множество ключей каждого из словарей в "ParamValues" с множеством элементов списка "Params"; правильно ли установлен "DefaultParamsIndex".
\item {\bf ReviewBlocks()}. Проверит каждый из блоков по таким критериям: 
	\begin{itemize}
	\item размеры блока ("Size") заданы неотрицательными числами;
	\item индекс уравнения по умолчанию и индекс начального условия по умолчанию заданы корректно;
	\item корректно заданы границы регионов уравнений, регионов на\-чаль\-ных условий, регионов граничных условий (при этом нет контроля за наложением одного региона на 	другой, это остается на совести пользователя); этим будет заниматься метод {\bf ReviewEqRegOrInitRegOrBoundReg()};
	\item одинаково количество уравнений в каждой системе, участвующей в задаче (система участвует в задаче, если она задана в списке "Equations" и при этом есть блок или часть блока, на котором задана именно эта система) (метод {\bf ReviewEquations()});
	\item количество компонент для каждого начального условия совпадает с количеством уравнений в каждой системе ( метод {\bf ReviewInitials()}). То же самое и для граничных условий (метод {\bf ReviewBounds()}).
	\end{itemize}
\item {\bf ReviewInput()}. Вызывает методы {\bf ReviewParameters()} и {\bf ReviewBlocks()}.
\end{itemize}
Недостатки проверяльщика:
\begin{itemize}
\item Не определено до конца, какие данные нужно проверять на корректность, а какие нет. Поэтому некоторые проверки могут быть лишними, некоторые --- отсутствовать.
\item Корректность ввода интерконнектов пока что нигде не проверяется!
\end{itemize}

%\newpage
\subsection{\Large Файл equationParser.py и парсинг уравнений, начальных и граничных условий}
Мозги парсера --- библиотека pyparsing. Этот файл (equationParser.py) содержит три класса:
\begin{itemize}
\item {\bf CorrectnessController}. Занимается проверкой уравнений и ма\-те\-ма\-ти\-чес\-ких функций (например, используемых в качестве начальных или граничных условий) на корректность ввода (например, пра\-виль\-ность расстановки скобок, правильность расстановки операторов $+$, $-$, $*$, $/$ и т.д.)
\item {\bf ParsePatternCreater}. Чтобы распарсить некое выражение сред\-ства\-ми pyparsing, нужно составить подходящую под это выражение грамматику. Нам надо парсить уравнения (выделять их правые части) и отдельно функции. Для этого надо создать 2 разных (но очень похожих) грамматики. Еще надо получать из левых частей уравнений список компонент искомой функции. Надо поэтому уравнения пар\-сить уже по-другому (выделять их левые части), т.е. есть не\-об\-хо\-ди\-мость создания третьей грамматики. Этот класс отвечает за создание этих грамматик.
\item {\bf MathExpressionParser}. С помощью созданной предыдущим клас\-сом грамматики либо парсит уравнение, либо математическую функ\-цию, либо возвращает список компонент искомой функции. \label{ci1}
\end{itemize}
Клиент использует только класс \ref{ci1}. Это происходит в методе {\bf generateAllPointInitials()} класса {\bf abstractGenerator} для того, чтобы пар\-сить начальные условия; в методе {\bf generateCentralFunctionCode()} того же класса для парсинга уравнений, необходимых для генерации центр\-аль\-ных функций; в реализациях матода {\bf generateBoundsAndIcs()} клас\-сов {\bf generator1D} и {\bf generator2D} (а в будущем и {\bf generator3D}).

Недостатки парсера:
\begin{itemize}
\item Работает долго.
\item Проверка на корректность ввода уравнений и математических функ\-ций (расстановка скобок и т.д.) сделана без использования средств pyparsing. Это порождает целый дополнительный класс, который занимается проверкой.
\end{itemize}

%\newpage
\subsection{\Large Файл newFuncGenerator.py, выполняющий основную работу}
Класс {\bf abstractGenerator} и его наследники {\bf generator1D} и {\bf generator2D} выполняют почти всю работу, связанную с генерацией (остав\-шу\-ю\-ся, но все же весьма значительную часть работы выполняют классы, на\-хо\-дя\-щи\-е\-ся в файлах \ref{i4}, \ref{i5}).

В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} со\-зда\-ет\-ся экземпляр класса {\bf FuncGenerator}, описание которого находится в рассматриваемом файле \ref{i3}. В конструкторе этого класса в зависимости от размерности задачи выбирается конкретная реализация генератора (т.е. полем этого класса становится экземпляр одного из трех классов {\bf generator1D}, {\bf generator2D}, {\bf generator3D}). В дальнейшем метод {\bf generateAllFunctions()} класса {\bf FuncGenerator} работает именно с этой конкретной реализацией. Также этот метод формирует список словарей {\bf functionMaps}, по которому формируется матрица пересчета и структура которго описана в файле definition в папке doc.

Вот полный список классов файла newFuncGenerator.py с их описанием:
\begin{itemize}
\item {\bf FuncGenerator}. Оперируя генератором для нужной размерности, определенная в нем функция {\bf generateAllFunctions()} генерирует:
	\begin{itemize}
	\item определения всех констант (дефайнов);
	\item функции для работы с начальными условиями и параметрами;
	\item для каждого блока --- набор центральных функций, набор гра\-нич\-ных, угловых и соединительных (интерконнектов) функций.
	\end{itemize}
\item {\bf abstractGenerator}. Содержит общие для всех трех генераторов поля и методы. Например, в нем определены методы генерирования конст\-ант (дефайнов) (метод {\bf generateAllDefinitions()}), функций для на\-чаль\-ных условий ({\bf generateAllPointInitials()}), параметров ({\bf generateParamFunction()}); методы генерирования функций для гра\-нич\-ных условий Дирихле ({\bf generateDirichlet()}) или Неймана, а также интерконнектов ({\bf generateNeumannOrInterconnect()}) (функ\-ция, генерирующая интерконнект, совпадает с функцией, ге\-не\-ри\-ру\-ю\-щей Неймана, просто ей передаются параметры с другим смыслом); метод генерирования центральных функций {\bf generateCentralFunction\-Co\-de()}.
\item {\bf generator1D}, {\bf generator2D}, {\bf generator3D}. Содержат спе\-ци\-фи\-чес\-кие методы и поля, нужные для обработки задачи указанной раз\-мер\-нос\-ти. Генератор {\bf generator3D} не работает и не изменялся очень очень давно. Важно то, что у этих классов есть общие методы {\bf getBlockInfo()} и {\bf generateBoundsAndIcs()}, которые вызываются в  методе {\bf generateAllFunctions()} класса {\bf FuncGenerator}. В первом методе определяются все уравнения, заданные на блоке (т.е. копится информация для генерации центральных функций), и для каждой границы определяются граничные условия и интервалы в клетках, на которых они действуют. А также начинает формироваться словарь из списка {\bf functionMaps}. Во втором методе генерируются граничные, угловые, соединительные функции и завершается формирование сло\-ва\-ря из списка {\bf functionMaps}.
\item {\bf InterconnectRegion}. Создан для того, чтобы унифицировать об\-ра\-бот\-ку границ двумерного (и может, трехмерного) блока, т.к. гра\-нич\-ные условия и соединения с другими блоками для массива {\bf functionMaps} надо представлять в одном и том же формате. Просто при создании экземпляра генератора для каждого блока создается список его соединительных регионов.
\item {\bf BoundCondition} и {\bf Connection}. Метод {\bf getBlockInfo()} в двумерном (и может, в трехмерном) случае составляет список элементов, которые есть экземпляры этих классов.
\end{itemize}

%\newpage
\subsection{\Large Файл rhsCodeGenerator.py и генерирование правых частей уравнений, заданных пользователем}
Файл содержит класс {\bf RHSCodeGenerator}, который отвечает за ге\-не\-ра\-цию правой части одного уарвнения системы, заданной пользователем, с учетом краевых условий или соединений. Пример возврата такой функ\-ции --- строка:
\begin{verbatim}
result[idx + 0] = params[0] * ((2.0 * DXM2 * (
        source[idx - Block0StrideX * Block0CELLSIZE + 0] - 
        source[idx + 0] + (0.0) * DX)));
\end{verbatim}

Этим занимается метод {\bf generateRightHandSideCode()}. Методы\\{\bf generateDirichlet()} и {\bf generateNeumannOrInterconnect()} класса\\
{\bf abstractGenerator} используют именно этот метод. Отдельная задача --- сгенерировать производную с нужным конечно-разностным при\-бли\-же\-ни\-ем. Подготовкой к такой генерации занимаются методы \\ {\bf callDerivGenerator()} и {\bf callSpecialDerivGenerator()}. А саму про\-из\-вод\-ную генерируют уже методы одного из двух классов, описанных в файле \ref{i5}.

%\newpage
\subsection{\Large Файл derivCodeGenerator.py и генерирование производных}
Т.к. в уравнении могут встретиться и чистые и смешанные производные, а смешанные производные в случае соединения блоков порождают много разных видов функций, которые необходимо сгенерировать, то удобно поручить генерирование чистых и смешанных производных разным клас\-сам. Эти классы:
\begin{itemize}
\item {\bf PureDerivGenerator};
\item {\bf MixDerivGenerator}.
\end{itemize}

\subsubsection{\large PureDerivGenerator}
Для центральной функции способен сгенерировать чистую производную любого порядка (потому что конечно-разностные приближения для них в этом случае содержат однотипные элементы, различно только их ко\-ли\-че\-ство и коэффициенты перед слагаемыми). В зависимости от того, какими значениями был проинициализирован экземпляр этого класса, за генерацию производной отвечает одна из трех функций:
\begin{itemize}
\item {\bf commonPureDerivativeAlternative()} --- генерировать производную для центральной функции или для граничной в случае, когда гра\-нич\-ное условие не влияет на производную (например, первая про\-из\-вод\-ная по $y$ вдоль границы $x = 0$);
\item {\bf specialPureDerivativeAlternative()} --- генерировать производную для граничной функции, когда граничное условие влияет на про\-из\-вод\-ную (например, производная по $x$ вдоль границы $x = x_{max}$);
\item {\bf interconnectPureDerivAlternative()} --- генерировать производную для функции-соединения (для интерконнекта).
\end{itemize} 

\subsubsection{\large MixDerivGenerator}
Пока что способен генерировать смешанные производные только второго порядка для несоединенных блоков. Функции-генераторы:
\begin{itemize}
\item {\bf commonMixedDerivativeAlternative()} --- генерировать производную для центральной функции;
\item {\bf specialMixedDerivativeAlternative()} --- генерировать производную для граничной функции.
\end{itemize}

Производные в углах двумерного блока генерируются по частям, а потом объединяются в обну строку в методе {\bf callDerivGenerator()} класса {\bf RHSCodeGenerator}.

\newpage
\section{\LARGE Конечно-разностные формулы, используемые при генерировании производных}
Расчетные функции (которые и генерирует генератор) отличаются друг от друга только выражениями, аппроксимирующими производные по пространственным пе\-ре\-мен\-ным. Если рассматриваемая система уравнений $n$-мерна (т.е. искомая функция --- это вектор-функция $u = (u_1, \ldots, u_n)$, $u_k = u_k(t,x,y,z)$, $k=\overline{1,n}$) и ни одно из уравнений не содержит смешанных производных и производных порядка выше вто\-ро\-го, то $i$-ое уравнение этой системы ($i = \overline{1,n}$) имеет вид:
\begin{multline*}
\frac{\partial u_i}{\partial t} = f\left(u_1, \frac{\partial u_1}{\partial x}, \frac{\partial u_1}{\partial y}, \frac{\partial u_1}{\partial z}, \frac{\partial^2 u_1}{\partial x^2}, \frac{\partial^2 u_1}{\partial y^2}, \frac{\partial^2 u_1}{\partial z^2}, \ldots , u_n, \frac{\partial u_n}{\partial x}, \frac{\partial u_n}{\partial y}, \frac{\partial u_n}{\partial z}, \frac{\partial^2 u_n}{\partial x^2}, \frac{\partial^2 u_n}{\partial y^2}, \frac{\partial^2 u_n}{\partial z^2} \right).
\end{multline*} 
Для простоты записи можно считать, что система одномерна, т.е. есть всего одно уравнение:
\begin{equation}\label{e1}
\frac{\partial u}{\partial t} = f\left(u, \frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial u}{\partial z}, \frac{\partial^2 u}{\partial x^2}, \frac{\partial^2 u}{\partial y^2}, \frac{\partial^2 u}{\partial z^2}\right).
\end{equation} 
Надо аппроксимировать все производные, стоящие в правой части \eqref{e1}. Нужны аппро\-кси\-ма\-ции для:
\begin{enumerate}
\item центральных функций;
\item функций для расчета границ блока; \label {i1}
\item функций для расчета вершин блока (в двумерном и трехмерном случаях);
\item функций для расчета ребер блока (в трехмерном случае). \label{i2}
\end{enumerate}
В \ref{i1}. - \ref{i2}. надо учитывать краевые условия (в случае краевых условий Неймана как раз и возникает необходимость аппроксимировать производные, а в случае условий Дирихле вместо правой части уравнения \eqref{e1} просто подставляется значение про\-из\-вод\-ной функции, являющейся этим условием), соединения блоков и то, что на разных частях одного блока могут быть заданы разные уравнения. Для приближения про\-из\-вод\-ных во всех функциях используются центральные конечные разности.

Пусть на рассматриваемом блоке введена сетка с шагами $\Delta x, \Delta y, \Delta z$ по про\-стран\-ствен\-ным переменным $x,y,z$ и введен шаг $\Delta t$ по времени $t$. Значения функции $u$ в узлах сетки далее обозначаются обычным образом:
\begin{equation*}
u^{\ell}_{ijk} := u(\ell\Delta t, i\Delta x, j\Delta y, k\Delta z),
\end{equation*}
а значения производных в узлах сетки пишутся похожим образом, например:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ijk} := \frac{\partial^2 u}{\partial y^2}(\ell\Delta t, i\Delta x, j\Delta y, k\Delta z).
\end{equation*}
Здесь $\ell = \overline{0,L}$, $i = \overline{0,M}$, $j = \overline{0,N}$, $k = \overline{0,P}$.

{\bf Замечание}: т.к. генератор все-таки умеет генерировать функции для задачи, когда в уравнении есть смешанные производные и при этом рассматриваются блоки без соединений, то для этой ситуации ниже также описаны формулы, используемые генератором для аппроксимации смешанных производных. Для такой задачи урав\-не\-ние \eqref{e1} выглядит по-другому:
\begin{equation}\label{e2}
\frac{\partial u}{\partial t} = f\left(u, \frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial u}{\partial z}, \frac{\partial^2 u}{\partial x\partial y}, \frac{\partial^2 u}{\partial x\partial z}, \frac{\partial^2 u}{\partial z\partial y}, \frac{\partial^2 u}{\partial x^2}, \frac{\partial^2 u}{\partial y^2}, \frac{\partial^2 u}{\partial z^2}\right).
\end{equation} 

\subsection{\Large Формулы для производных в центральных функциях}
В центральных функциях для приближения производных используется самый обычный вид конечно-разностных формул.

Первая производная (например, по $z$):
\begin{equation*}
\left(\frac{\partial u}{\partial z}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{ijk+1} - u^{\ell}_{ijk-1}}{2\Delta z}
\end{equation*}

Вторая чистая производная (например, по $yy$):
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{ij+1k} - 2u^{\ell}_{ijk} + u^{\ell}_{ij-1k}}{(\Delta y)^2}
\end{equation*}

Для центральных функций смешанные производные генерировать очень легко. Смешанная производная (например, по $xz$):
\begin{equation*}
\left(\frac{\partial^2 u}{\partial x\partial z}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{i+1jk+1} - u^{\ell}_{i-1jk+1} - u^{\ell}_{i+1jk-1} + u^{\ell}_{i-1jk-1}}{4\Delta x\Delta z}
\end{equation*}

\subsection{\Large Формулы для производных в функциях расчета границ блока}
Рассмотрим какую-нибудь границу блока, например, $y = 0$. Пусть на этой границе задано условие Неймана:
\begin{equation}\label{e3}
\frac{\partial u}{\partial y}(t,x,0,z) = \varphi(t,x,z).
\end{equation}

\end{document}
