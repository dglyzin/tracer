\documentclass[a4paper]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts,amssymb,amscd,amsmath}
\usepackage[left=3cm, right=2cm, top=2cm, bottom=2cm]{geometry}

\begin{document}
\begin{center}
{\LARGE \bf Описание генератора функций}
\end{center}

\Large
\section*{Введение. Текущие возможности и актуальные файлы}
Сейчас ($13.07.15$) генератор умеет генерировать функции в таких случаях:
\begin{itemize}
\item одномерный случай, ни в одном уравнении нет производных порядка выше второго --- генерируются {\bf все} нужные функции;
\item двумерный случай, ни в одном уравнении не содержится смешанных производных и производных порядка выше второго --- тоже все функ\-ции;
\item двумерный случай, в уравнениях могут содержаться смешанные про\-из\-вод\-ные второго порядка, ни в одном уравнении нет производных порядка выше второго --- правильно может быть обработана только ситуация, когда нет соединяющихся блоков (т.е. при генерировании функций не приходится приближать смешанные производные в мес\-тах соединений).
\end{itemize}

Для генерирования функций используются файлы, находящиеся в пап\-ке domainmodel:
\begin{enumerate}
\item  customOfficer.py; \label{i1}
\item equationParser.py; \label{i2}
\item newFuncGenerator.py; \label{i3}
\item  rhsCodeGenerator.py; \label{i4}
\item derivCodeGenerator.py; \label{i5}
\item someFuncs.py; \label{i6}
\item DerivHandler.py. \label{i7}
\end{enumerate}

Файлы \ref{i6} и \ref{i7} используются для генерации, но функции, лежащие в них, могут использоваться и для других целей. Из файла \ref{i6} для генерации используются функции {\bf NewtonBinomCoefficient()}, {\bf generateCodeForMathFunction()}, {\bf determineNameOfBoundary()}, {\bf RectSquare()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Функции {\bf factorial()} и {\bf getCellCountAlongLine()} из этого же файла используются функциями {\bf NewtonBinomCoefficient()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Файл \ref{i7} содержит функцию, которая находит порядок старшей про\-из\-вод\-ной.

\section{Файл customOfficer.py и проверка входных данных}
Файл \ref{i1} (customOfficer.py) создан для проверки некоторых введенных в *.json данных на корректность перед запуском генерации функций. Этот файл содержит класс {\bf Reviewer}, который связан с внешним миром методом {\bf ReviewInput()}. В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} создается экземпляр класса {\bf Reviewer} и вызывается его метод {\bf ReviewInput()}. Этот метод проверит правильность введения бло\-ков и параметров.

Основные методы класса {\bf Reviewer}:
\begin{itemize}
\item {\bf ReviewParameters()}. Проверит, нет ли в списке параметров "Pa\-rams" повторяющихся имен; совпадает ли множество ключей каждого из словарей в "ParamValues" с множеством элементов списка "Params"; правильно ли установлен "DefaultParamsIndex".
\item {\bf ReviewBlocks()}. Проверит каждый из блоков по таким критериям: 
	\begin{itemize}
	\item размеры блока ("Size") заданы неотрицательными числами;
	\item индекс уравнения по умолчанию и индекс начального условия по умолчанию заданы корректно;
	\item корректно заданы границы регионов уравнений, регионов на\-чаль\-ных условий, регионов граничных условий (при этом нет контроля за наложением одного региона на 	другой, это остается на совести пользователя); этим будет заниматься метод {\bf ReviewEqRegOrInitRegOrBoundReg()};
	\item одинаково количество уравнений в каждой системе, участвующей в задаче (система участвует в задаче, если она задана в списке "Equations" и при этом есть блок или часть блока, на котором задана именно эта система) (метод {\bf ReviewEquations()});
	\item количество компонент для каждого начального условия совпадает с количеством уравнений в каждой системе ( метод {\bf ReviewInitials()}). То же самое и для граничных условий (метод {\bf ReviewBounds()}).
	\end{itemize}
\item {\bf ReviewInput()}. Вызывает методы {\bf ReviewParameters()} и {\bf ReviewBlocks()}.
\end{itemize}
Недостатки проверяльщика:
\begin{itemize}
\item Не определено до конца, какие данные нужно проверять на корректность, а какие нет. Поэтому некоторые проверки могут быть лишними, некоторые --- отсутствовать.
\item Корректность ввода интерконнектов пока что нигде не проверяется!
\end{itemize}

\section{Файл equationParser.py и парсинг уравнений, начальных и граничных условий}
Мозги парсера --- библиотека pyparsing. Этот файл (equationParser.py) содержит три класса:
\begin{itemize}
\item {\bf CorrectnessController}. Занимается проверкой уравнений и ма\-те\-ма\-ти\-чес\-ких функций (например, используемых в качестве начальных или граничных условий) на корректность ввода (например, пра\-виль\-ность расстановки скобок, правильность расстановки операторов $+$, $-$, $*$, $/$ и т.д.)
\item {\bf ParsePatternCreater}. Чтобы распарсить некое выражение сред\-ства\-ми pyparsing, нужно составить подходящую под это выражение грамматику. Нам надо парсить уравнения (выделять их правые части) и отдельно функции. Для этого надо создать 2 разных (но очень похожих) грамматики. Еще надо получать из левых частей уравнений список компонент искомой функции. Надо поэтому уравнения пар\-сить уже по-другому (выделять их левые части), т.е. есть не\-об\-хо\-ди\-мость создания третьей грамматики. Этот класс отвечает за создание этих грамматик.
\item {\bf MathExpressionParser}. С помощью созданной предыдущим клас\-сом грамматики либо парсит уравнение, либо математическую функ\-цию, либо возвращает список компонент искомой функции. \label{ci1}
\end{itemize}
Клиент использует только класс \ref{ci1}. Это происходит в методе {\bf generateAllPointInitials()} класса {\bf abstractGenerator} для того, чтобы пар\-сить начальные условия; в методе {\bf generateCentralFunctionCode()} того же класса для парсинга уравнений, необходимых для генерации центр\-аль\-ных функций; в реализациях матода {\bf generateBoundsAndIcs()} клас\-сов {\bf generator1D} и {\bf generator2D} (а в будущем и {\bf generator3D}).

Недостатки парсера:
\begin{itemize}
\item Работает долго.
\item Проверка на корректность ввода уравнений и математических функ\-ций (расстановка скобок и т.д.) сделана без использования средств pyparsing. Это порождает целый дополнительный класс, который занимается проверкой.
\end{itemize}

\newpage
\section{Файл newFuncGenerator.py, выполняющий основную работу}
Класс {\bf abstractGenerator} и его наследники {\bf generator1D} и {\bf generator2D} выполняют почти всю работу, связанную с генерацией (остав\-шу\-ю\-ся, но все же весьма значительную часть работы выполняют классы, на\-хо\-дя\-щи\-е\-ся в файлах \ref{i4}, \ref{i5}).

В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} со\-зда\-ет\-ся экземпляр класса {\bf FuncGenerator}, описание которого находится в рассматриваемом файле \ref{i3}. В конструкторе этого класса в зависимости от размерности задачи выбирается конкретная реализация генератора (т.е. полем этого класса становится экземпляр одного из трех классов {\bf generator1D}, {\bf generator2D}, {\bf generator3D}). В дальнейшем метод {\bf generateAllFunctions()} класса {\bf FuncGenerator} работает именно с этой конкретной реализацией. Также этот метод формирует список словарей {\bf functionMaps}, по которому формируется матрица пересчета и структура которго описана в файле definition в папке doc.

Вот полный список классов файла newFuncGenerator.py с их описанием:
\begin{itemize}
\item {\bf FuncGenerator}. Оперируя генератором для нужной размерности, определенная в нем функция {\bf generateAllFunctions()} генерирует:
	\begin{itemize}
	\item определения всех констант (дефайнов);
	\item функции для работы с начальными условиями и параметрами;
	\item для каждого блока --- набор центральных функций, набор гра\-нич\-ных, угловых и соединительных (интерконнектов) функций.
	\end{itemize}
\item {\bf abstractGenerator}. Содержит общие для всех трех генераторов поля и методы. Например, в нем определены методы генерирования конст\-ант (дефайнов) (метод {\bf generateAllDefinitions()}), функций для на\-чаль\-ных условий ({\bf generateAllPointInitials()}), параметров ({\bf generateParamFunction()}); методы генерирования функций для гра\-нич\-ных условий Дирихле ({\bf generateDirichlet()}) или Неймана, а также интерконнектов ({\bf generateNeumannOrInterconnect()}) (функ\-ция, генерирующая интерконнект, совпадает с функцией, ге\-не\-ри\-ру\-ю\-щей Неймана, просто ей передаются параметры с другим смыслом); метод генерирования центральных функций {\bf generateCentralFunction\-Co\-de()}.
\item {\bf generator1D}, {\bf generator2D}, {\bf generator3D}. Содержат спе\-ци\-фи\-чес\-кие методы и поля, нужные для обработки задачи указанной раз\-мер\-нос\-ти. Генератор {\bf generator3D} не работает и не изменялся очень очень давно. Важно то, что у этих классов есть общие методы {\bf getBlockInfo()} и {\bf generateBoundsAndIcs()}, которые вызываются в  методе {\bf generateAllFunctions()} класса {\bf FuncGenerator}. В первом методе определяются все уравнения, заданные на блоке (т.е. копится информация для генерации центральных функций), и для каждой границы определяются граничные условия и интервалы в клетках, на которых они действуют. А также начинает формироваться словарь из списка {\bf functionMaps}. Во втором методе генерируются граничные, угловые, соединительные функции и завершается формирование сло\-ва\-ря из списка {\bf functionMaps}.
\item {\bf InterconnectRegion}. Создан для того, чтобы унифицировать об\-ра\-бот\-ку границ двумерного (и может, трехмерного) блока, т.к. гра\-нич\-ные условия и соединения с другими блоками для массива {\bf functionMaps} надо представлять в одном и том же формате. Просто при создании экземпляра генератора для каждого блока создается список его соединительных регионов.
\item {\bf BoundCondition} и {\bf Connection}. Метод {\bf getBlockInfo()} в двумерном (и может, в трехмерном) случае составляет список элементов, которые есть экземпляры этих классов.
\end{itemize}

\section{Файл rhsCodeGenerator.py и генерирование правых частей уравнений, заданных пользователем}
Файл содержит класс {\bf RHSCodeGenerator}, который отвечает за ге\-не\-ра\-цию правой части одного уарвнения системы, заданной пользователем, с учетом краевых условий или соединений. Пример возврата такой функ\-ции --- строка:
\begin{verbatim}
result[idx + 0] = params[0] * ((2.0 * DXM2 * (
        source[idx - Block0StrideX * Block0CELLSIZE + 0] - 
        source[idx + 0] + (0.0) * DX)));
\end{verbatim}

Этим занимается метод {\bf generateRightHandSideCode()}. Методы\\{\bf generateDirichlet()} и {\bf generateNeumannOrInterconnect()} класса\\
{\bf abstractGenerator} используют именно этот метод. Отдельная задача --- сгенерировать производную с нужным конечно-разностным при\-бли\-же\-ни\-ем. Подготовкой к такой генерации занимаются методы \\ {\bf callDerivGenerator()} и {\bf callSpecialDerivGenerator()}. А саму про\-из\-вод\-ную генерируют уже методы одного из двух классов, описанных в файле \ref{i5}.

\newpage
\section{Файл derivCodeGenerator.py и генерирование производных}
Т.к. в уравнении могут встретиться и чистые и смешанные производные, а смешанные производные в случае соединения блоков порождают много разных видов функций, которые необходимо сгенерировать, то удобно поручить генерирование чистых и смешанных производных разным клас\-сам. Эти классы:
\begin{itemize}
\item {\bf PureDerivGenerator};
\item {\bf MixDerivGenerator}.
\end{itemize}

\subsection{PureDerivGenerator}
Для центральной функции способен сгенерировать чистую производную любого порядка (потому что конечно-разностные приближения для них в этом случае содержат однотипные элементы, различно только их ко\-ли\-че\-ство и коэффициенты перед слагаемыми). В зависимости от того, какими значениями был проинициализирован экземпляр этого класса, за генерацию производной отвечает одна из трех функций:
\begin{itemize}
\item {\bf commonPureDerivativeAlternative()} --- генерировать производную для центральной функции или для граничной в случае, когда гра\-нич\-ное условие не влияет на производную (например, первая про\-из\-вод\-ная по $y$ вдоль границы $x = 0$);
\item {\bf specialPureDerivativeAlternative()} --- генерировать производную для граничной функции, когда граничное условие влияет на про\-из\-вод\-ную (например, производная по $x$ вдоль границы $x = x_{max}$);
\item {\bf interconnectPureDerivAlternative()} --- генерировать производную для функции-соединения (для интерконнекта).
\end{itemize} 

\subsection{MixDerivGenerator}
Пока что способен генерировать смешанные производные только второго порядка для несоединенных блоков. Функции-генераторы:
\begin{itemize}
\item {\bf commonMixedDerivativeAlternative()} --- генерировать производную для центральной функции;
\item {\bf specialMixedDerivativeAlternative()} --- генерировать производную для граничной функции.
\end{itemize}

Производные в углах двумерного блока генерируются по частям, а потом объединяются в обну строку в методе {\bf callDerivGenerator()} класса {\bf RHSCodeGenerator}.

\end{document}
