\documentclass[a4paper]{article}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsfonts,amssymb,amscd,amsmath}
\usepackage{graphicx}
\usepackage[left=1cm, right=1cm, top=1cm, bottom=1cm]{geometry}

\begin{document}
\begin{center}
{\Huge \bf Описание генератора функций}
\end{center}

\tableofcontents
\newpage

\large
\section*{\LARGE Введение. Возможности, файлы, идея}
\addcontentsline{toc}{section}{\LARGE Введение. Возможности, файлы, идея}
Сейчас ($31.08.15$)  генератор умеет генерировать функции в таких случаях:
\begin{itemize}
\item одномерный случай с соединениями, ни в одном уравнении нет про\-из\-вод\-ных порядка выше второго;
\item двумерный случай с соединениями, ни в одном уравнении не со\-дер\-жит\-ся сме\-шан\-ных производных и производных порядка выше второго;
\item двумерный случай, в уравнениях могут содержаться смешанные про\-из\-вод\-ные второго порядка, ни в одном уравнении нет производных порядка выше второго --- правильно может быть обработана только ситуация, когда нет соединяющихся блоков (т.е. при генерировании функций не приходится приближать смешанные производные в мес\-тах соединений).
\item трехмерный случай с соединениями,  ни в одном уравнении не со\-дер\-жит\-ся сме\-шан\-ных производных и производных порядка выше второго.
\end{itemize}

Для генерирования функций используются файлы, находящиеся в пап\-ке domainmodel:
\begin{enumerate}
\item customOfficer.py; \label{i1}
\item equationParser.py; \label{i2}
\item funcGenerator.py; \label{i3}
\item abstractGenerator.py; \label{i4}
\item generator1D.py, generator2D.py, generator3D.py; \label{i5}
\item  rhsCodeGenerator.py; \label{i6}
\item derivCodeGenerator.py; \label{i7}
\item someFuncs.py; \label{i8}
\item DerivHandler.py. \label{i9}
\end{enumerate}

Файлы \ref{i8} и \ref{i9} используются для генерации, но функции, лежащие в них, могут использоваться и для других целей. Из файла \ref{i8} для генерации используются функции {\bf NewtonBinomCoefficient()}, {\bf generateCodeForMathFunction()}, {\bf determineNameOfBoundary()}, {\bf RectSquare()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Функции {\bf factorial()} и {\bf getCellCountAlongLine()} из этого же файла используются функциями {\bf NewtonBinomCoefficient()}, {\bf determineCellIndexOfStartOfConnection2D()}, {\bf getRanges()}. Файл \ref{i9} содержит функцию, которая находит порядок старшей про\-из\-вод\-ной.

\bigskip
{\bf Основная идея}.

Количество и вид рассчетных функций, которые надо сгенерировать, зависит от области, на которой задана система. Центральных функций для блока столько, сколько уравнений задано внутри блока. Сначала генерируются они. Потом ге\-не\-ри\-ру\-ют\-ся граничные функции.

Сначала все границы каждого блока разбиваются на регионы, каждый из которых обладает уникальными по сравнению с другими регионами свойствами. Свойствами региона являются:
\begin{itemize}
\item система уравнений (т.к. в блоке может быть задано несколько систем),
\item краевое условие или наличие соединения с другим блоком,
\item границы
\end{itemize}
В зависимости от этих свойств регион может быть либо куском соединения с другим блоком, либо куском границы, на который наложено краевое условие. В первом случае регион будет экземпляром класса Connection, во втором случае -- класса BoundCondition. Каждый из этих классов знает систему уравнений, которая задана пользователем на этом регионе, и границы этого региона. Также есть специфические поля. Для каждой границы блока составляется список таких регионов. Из этих списков составляется список, характерный для всего блока. Получилось, что каждому региону соответствует рассчетная функция, которую предстоит сгенерировать. И никаким двум регионам не соответствуют одинаковые рассчетные функции. Теперь выполняется проход по всем регионам в составленном списке, и для каждого региона генерируется соответствующая функция.

Затем генерирование сначала центральных, потом граничных функций по\-вто\-ря\-ет\-ся для следующего блока.

В одномерном, двумерном и трехмерном случаях различаются способы обхода границ блоков, поэтому созданы отдельные классы для обработки $1$D, $2$D, $3$D. А на рисунке~\ref{pict1} нарисован пример сложной области в 2D.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{blocksExample.PNG}
\caption{Пример сложной области в 2D}\label{pict1}
\end{figure}

Для первого блока области, нарисованной на рисунке~\ref{pict1}, нужно сгенерировать такие функции: центральную для каждого уравнения (т.е. 3 штуки); на левую гра\-ни\-цу: два дефолтных Неймана (для 1 и 2 уравнений), два пользовательских Неймана (для 1 и 2 уравнений), 2 условия Дирихле (для 2 и дефолтного уравнений); на верхнюю границу: один дефолтный Нейман; на правую границу: один дефолтный Нейман, 2 функции для соединение со вторым блоком (для 1 и 2 уравнений), один пользовательский Нейман, 2 функции соединения с  третьим блоком (для 2 и де\-фолт\-но\-го уравнений); на нижнюю границу: один пользовательский Нейман, одно соединение с четвертым блоком. В соответствии с такими требованиями и происходит разбиение границ первого блока на регионы с уникальными свойствами. В 1D все намного проще, а в 3D почти как в 2D.

{\bf 1D}

Тут все просто, потому что каждая из границ каждого блока состоит из един\-ствен\-ной клетки. Для каждой границы каждого блока сначала проверяется, есть ли в массиве интерконнектов подходящий интерконнект. Если есть, то сразу генерируется нужная рассчетная функция, иначе генерируется функция с краевым условием (де\-фолт\-ным или не дефолтным).

{\bf 2D}

Тут обход границ происходит в сторону возрастания координаты по оси, па\-рал\-лель\-ной границе. Все регионы располагаются в массиве в таком же порядке. Для создания рассчетных функций на вершины блока выбирается крайний регион с каж\-дой стороны каждого массива регионов и создаются 4 пары вида (условие на стороне 0, условие на стороне 2), (условие на стороне 2, условие на стороне 1), (условие на стороне 1, условие на стороне 3), (условие на стороне 3, условие на стороне 0). Т.к. они знают информацию о своих соединениях или краевых условиях, то по ним генерируются функции на вершины.

{\bf 3D}

Тут сложность в том, что граница блока -- это прямоугольник, поэтому обходить его в каком-то направлении нельзя. В этом случае для каждой границы сначала обходится список систем уравнений (определяется, какие уравнения заданы на этой границе) и вся граница разбивается на меньшие прямоугольники с уникальными системами. Затем для каждого из таких прямоугольников определяется, заданы ли на них (или на отдельных их частях) краевые условия или есть соединения с другими блоками.

\newpage
\section{\LARGE{Описание основных файлов}}
\subsection{\Large Файл customOfficer.py и проверка входных данных}
Файл \ref{i1} (customOfficer.py) создан для проверки некоторых введенных в *.json данных на корректность перед запуском генерации функций. Этот файл содержит класс {\bf Reviewer}, который связан с внешним миром методом {\bf ReviewInput()}. В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} создается экземпляр класса {\bf Reviewer} и вызывается его метод {\bf ReviewInput()}. Этот метод проверит правильность введения бло\-ков и параметров.

Основные методы класса {\bf Reviewer}:
\begin{itemize}
\item {\bf ReviewParameters()}. Проверит, нет ли в списке параметров "Pa\-rams" повторяющихся имен; совпадает ли множество ключей каждого из словарей в "ParamValues" с множеством элементов списка "Params"; правильно ли установлен "DefaultParamsIndex".
\item {\bf ReviewBlocks()}. Проверит каждый из блоков по таким критериям: 
	\begin{itemize}
	\item размеры блока ("Size") заданы неотрицательными числами;
	\item индекс уравнения по умолчанию и индекс начального условия по умолчанию заданы корректно;
	\item корректно заданы границы регионов уравнений, регионов на\-чаль\-ных условий, регионов граничных условий (при этом нет контроля за наложением одного региона на 	другой, это остается на совести пользователя); этим будет заниматься метод {\bf ReviewEqRegOrInitRegOrBoundReg()};
	\item одинаково количество уравнений в каждой системе, участвующей в задаче (система участвует в задаче, если она задана в списке "Equations" и при этом есть блок или часть блока, на котором задана именно эта система) (метод {\bf ReviewEquations()});
	\item количество компонент для каждого начального условия совпадает с количеством уравнений в каждой системе ( метод {\bf ReviewInitials()}). То же самое и для граничных условий (метод {\bf ReviewBounds()}).
	\end{itemize}
\item {\bf ReviewInput()}. Вызывает методы {\bf ReviewParameters()} и {\bf ReviewBlocks()}.
\end{itemize}
Недостатки проверяльщика:
\begin{itemize}
\item Не определено до конца, какие данные нужно проверять на корректность, а какие нет. Поэтому некоторые проверки могут быть лишними, некоторые --- отсутствовать.
\item Корректность ввода интерконнектов пока что нигде не проверяется!
\end{itemize}

\newpage
\subsection{\Large Файл equationParser.py и формат ввода уравнений, начальных и граничных условий}
{\bf Формат и правила ввода уравнений и математических функций}:
\begin{itemize}
\item В левой части уравнения обязательно должно стоять имя компоненты искомой функции, символ ', обозначающий производную по $t$, затем после любого количества пробелов -- знак равно, затем после любого количества пробелов -- математическая функция;
\item Между отдельными символами внутри математической функции может стоять любое количество пробелов, но названия элементарных функций обязательно должны быть записаны без пробелов (например, нельзая написать '$c\ \ \ os(x)$', но можно написать '$cos(\ \ \ x)$' или '$cos\ \ \ (x)$'!);
\item Среди элементарных функций поддерживаются следующие: 'exp', 'sin', 'cos', 'tan', 'sinh', 'tanh', 'sqrt', 'log' ('log' --- натуральный логарифм);
\item Для возведения какого-нибудь выражения $F$ в {\bf натуральную} степень $n$ надо написать \begin{verbatim}'(F)^n'\end{verbatim}
\item Аргумент любой функции надо писать в скобках, даже если он состоит из одного символа;
\item Имена параметров и компонент искомой функции могут быть любыми, а имена независимых переменных всегда такие: $t, x, y, z$;
\item Естественно, при вводе начальных условий нельзя, чтобы функция, играющая роль начального условия, зависела от $t$; Также (при задании граничных условий) надо внимательно смотреть, на какую границу наложено граничное условие, и соответствующая пространственная переменная должна отсутствовать.
\end{itemize}
Мозги парсера --- библиотека pyparsing. Этот файл (equationParser.py) содержит три класса:
\begin{itemize}
\item {\bf CorrectnessController}. Занимается проверкой уравнений и ма\-те\-ма\-ти\-чес\-ких функций (например, используемых в качестве начальных или граничных условий) на корректность ввода (например, пра\-виль\-ность расстановки скобок, правильность расстановки операторов $+$, $-$, $*$, $/$ и т.д.)
\item {\bf ParsePatternCreater}. Чтобы распарсить некое выражение сред\-ства\-ми pyparsing, нужно составить подходящую под это выражение грамматику. Нам надо парсить уравнения (выделять их правые части) и отдельно функции. Для этого надо создать 2 разных (но очень похожих) грамматики. Еще надо получать из левых частей уравнений список компонент искомой функции. Надо поэтому уравнения пар\-сить уже по-другому (выделять их левые части), т.е. есть не\-об\-хо\-ди\-мость создания третьей грамматики. Этот класс отвечает за создание этих грамматик.
\item {\bf MathExpressionParser}. С помощью созданной предыдущим клас\-сом грамматики либо парсит уравнение, либо математическую функ\-цию, либо возвращает список компонент искомой функции.
\end{itemize}
Клиент использует только последний из этих классов. Это происходит в методе {\bf generateAllPointInitials()} класса {\bf abstractGenerator} для того, чтобы пар\-сить начальные условия; в методе {\bf generateCentralFunctionCode()} того же класса для парсинга уравнений, необходимых для генерации центр\-аль\-ных функций; в реализациях матода {\bf generateBoundsAndIcs()} клас\-сов {\bf generator1D} и {\bf generator2D} (а в будущем и {\bf generator3D}).

\bigskip
{\bf Недостатки парсера}:
\begin{itemize}
\item Работает долго.
\item Проверка на корректность ввода уравнений и математических функ\-ций (расстановка скобок и т.д.) сделана без использования средств pyparsing. Это порождает целый дополнительный класс, который занимается проверкой.
\end{itemize}

{\bf Философия.}

Вообще использование pyparsing может быть лишним. Потому что с его помощью сначала строка преобразуется в список строк (в основном все строки там односимвольные, полноценные строки -- это только производные, например, $"D[U,\{x,1\},\{y,1\}]"$ и степени), а потом только отдельные элементы этого списка (производные; выражения, возведенные в степень; компоненты искомой функции; имена параметров) заменяются на выражения C$++$. Использование pyparsing удобно тем, что позволяет парсить математические функции любой вложенности, например $[cos(sqrt(x + y) - sin(300 * cos(y)) * y)]^{59}$, довольно легко (например, pyparsing сам умеет работать с любым количеством пробелов, поэтому во время парсинга об этом думать не приходится). Также pyparsing позволяет удобно парсить выражения, где имена переменных или параметров состоят больше чем из одного символа.

\newpage
\subsection{\Large Файлы funcGenerator.py, abstractGenerator.py, generator1D.py, generator2D.py, generator3D.py}
Класс {\bf abstractGenerator} и его наследники {\bf generator1D}, {\bf generator2D} и {\bf generator3D} выполняют почти всю работу, связанную с генерацией (остав\-шу\-ю\-ся, но все же весьма значительную часть работы выполняют классы, на\-хо\-дя\-щи\-е\-ся в файлах \ref{i4}, \ref{i5}).

В методе {\bf createCPPandGetFunctionMaps()} класса {\bf Model} со\-зда\-ет\-ся экземпляр класса {\bf FuncGenerator}, описание которого находится в рассматриваемом файле \ref{i3}. В конструкторе этого класса в зависимости от размерности задачи выбирается конкретная реализация генератора (т.е. полем этого класса становится экземпляр одного из трех классов {\bf generator1D}, {\bf generator2D}, {\bf generator3D}). В дальнейшем метод {\bf generateAllFunctions()} класса {\bf FuncGenerator} работает именно с этой конкретной реализацией. Также этот метод формирует список словарей {\bf functionMaps}, по которому формируется матрица пересчета и структура которго описана в файле definition в папке doc.

Вот полный список классов файла newFuncGenerator.py с их описанием:
\begin{itemize}
\item {\bf FuncGenerator}. Оперируя генератором для нужной размерности, определенная в нем функция {\bf generateAllFunctions()} генерирует:
	\begin{itemize}
	\item определения всех констант (дефайнов);
	\item функции для работы с начальными условиями и параметрами;
	\item для каждого блока --- набор центральных функций, набор гра\-нич\-ных, угловых и соединительных (интерконнектов) функций.
	\end{itemize}
\item {\bf abstractGenerator}. Содержит общие для всех трех генераторов поля и методы. Например, в нем определены методы генерирования конст\-ант (дефайнов) (метод {\bf generateAllDefinitions()}), функций для на\-чаль\-ных условий ({\bf generateAllPointInitials()}), параметров ({\bf generateParamFunction()}); методы генерирования функций для гра\-нич\-ных условий Дирихле ({\bf generateDirichlet()}) или Неймана, а также интерконнектов ({\bf generateNeumannOrInterconnect()}) (функ\-ция, генерирующая интерконнект, совпадает с функцией, ге\-не\-ри\-ру\-ю\-щей Неймана, просто ей передаются параметры с другим смыслом); метод генерирования центральных функций {\bf generateCentralFunction\-Co\-de()}.
\item {\bf generator1D}, {\bf generator2D}, {\bf generator3D}. Содержат спе\-ци\-фи\-чес\-кие методы и поля, нужные для обработки задачи указанной раз\-мер\-нос\-ти. Генератор {\bf generator3D} не работает и не изменялся очень очень давно. Важно то, что у этих классов есть общие методы {\bf getBlockInfo()} и {\bf generateBoundsAndIcs()}, которые вызываются в  методе {\bf generateAllFunctions()} класса {\bf FuncGenerator}. В первом методе определяются все уравнения, заданные на блоке (т.е. копится информация для генерации центральных функций), и для каждой границы определяются граничные условия и интервалы в клетках, на которых они действуют. А также начинает формироваться словарь из списка {\bf functionMaps}. Во втором методе генерируются граничные, угловые, соединительные функции и завершается формирование сло\-ва\-ря из списка {\bf functionMaps}.
\item {\bf InterconnectRegion}. Создан для того, чтобы унифицировать об\-ра\-бот\-ку границ двумерного (и может, трехмерного) блока, т.к. гра\-нич\-ные условия и соединения с другими блоками для массива {\bf functionMaps} надо представлять в одном и том же формате. Просто при создании экземпляра генератора для каждого блока создается список его соединительных регионов.
\item {\bf BoundCondition} и {\bf Connection}. Метод {\bf getBlockInfo()} в двумерном (и может, в трехмерном) случае составляет список элементов, которые есть экземпляры этих классов.
\end{itemize}

\newpage
\subsection{\Large Файл rhsCodeGenerator.py и генерирование правых частей уравнений, заданных пользователем}
Файл содержит класс {\bf RHSCodeGenerator}, который отвечает за ге\-не\-ра\-цию правой части одного уарвнения системы, заданной пользователем, с учетом краевых условий или соединений. Пример возврата такой функ\-ции --- строка:
\begin{verbatim}
result[idx + 0] = params[0] * ((2.0 * DXM2 * (
        source[idx - Block0StrideX * Block0CELLSIZE + 0] - 
        source[idx + 0] + (0.0) * DX)));
\end{verbatim}

Этим занимается метод {\bf generateRightHandSideCode()}. Методы\\{\bf generateDirichlet()} и {\bf generateNeumannOrInterconnect()} класса\\
{\bf abstractGenerator} используют именно этот метод. Отдельная задача --- сгенерировать производную с нужным конечно-разностным при\-бли\-же\-ни\-ем. Подготовкой к такой генерации занимаются методы \\ {\bf callDerivGenerator()} и {\bf callSpecialDerivGenerator()}. А саму про\-из\-вод\-ную генерируют уже методы одного из двух классов, описанных в файле \ref{i5}.

\newpage
\subsection{\Large Файл derivCodeGenerator.py и генерирование производных}
Т.к. в уравнении могут встретиться и чистые и смешанные производные, а смешанные производные в случае соединения блоков порождают много разных видов функций, которые необходимо сгенерировать, то удобно поручить генерирование чистых и смешанных производных разным клас\-сам. Эти классы:
\begin{itemize}
\item {\bf PureDerivGenerator};
\item {\bf MixDerivGenerator}.
\end{itemize}

\subsubsection{\large PureDerivGenerator}
Для центральной функции способен сгенерировать чистую производную любого порядка (потому что конечно-разностные приближения для них в этом случае содержат однотипные элементы, различно только их ко\-ли\-че\-ство и коэффициенты перед слагаемыми). В зависимости от того, какими значениями был проинициализирован экземпляр этого класса, за генерацию производной отвечает одна из трех функций:
\begin{itemize}
\item {\bf commonPureDerivativeAlternative()} --- генерировать производную для центральной функции или для граничной в случае, когда гра\-нич\-ное условие не влияет на производную (например, первая про\-из\-вод\-ная по $y$ вдоль границы $x = 0$);
\item {\bf specialPureDerivativeAlternative()} --- генерировать производную для граничной функции, когда граничное условие влияет на про\-из\-вод\-ную (например, производная по $x$ вдоль границы $x = x_{max}$);
\item {\bf interconnectPureDerivAlternative()} --- генерировать производную для функции-соединения (для интерконнекта).
\end{itemize} 

\subsubsection{\large MixDerivGenerator}
Пока что способен генерировать смешанные производные только второго порядка для несоединенных блоков. Функции-генераторы:
\begin{itemize}
\item {\bf commonMixedDerivativeAlternative()} --- генерировать производную для центральной функции;
\item {\bf specialMixedDerivativeAlternative()} --- генерировать производную для граничной функции.
\end{itemize}

Производные в углах двумерного блока генерируются по частям, а потом объединяются в обну строку в методе {\bf callDerivGenerator()} класса {\bf RHSCodeGenerator}.

\newpage
\section{\LARGE Конечно-разностные формулы, используемые при генерировании производных}
Расчетные функции (которые и генерирует генератор) отличаются друг от друга только выражениями, аппроксимирующими производные по пространственным пе\-ре\-мен\-ным. Если рассматриваемая система уравнений $n$-мерна (т.е. искомая функция --- это вектор-функция $u = (u_1, \ldots, u_n)$, $u_k = u_k(t,x,y,z)$, $k=\overline{1,n}$) и ни одно из уравнений не содержит смешанных производных и производных порядка выше вто\-ро\-го, то $i$-ое уравнение этой системы ($i = \overline{1,n}$) имеет вид:
\begin{multline*}
\frac{\partial u_i}{\partial t} = f\left(u_1, \frac{\partial u_1}{\partial x}, \frac{\partial u_1}{\partial y}, \frac{\partial u_1}{\partial z}, \frac{\partial^2 u_1}{\partial x^2}, \frac{\partial^2 u_1}{\partial y^2}, \frac{\partial^2 u_1}{\partial z^2}, \ldots , u_n, \frac{\partial u_n}{\partial x}, \frac{\partial u_n}{\partial y}, \frac{\partial u_n}{\partial z}, \frac{\partial^2 u_n}{\partial x^2}, \frac{\partial^2 u_n}{\partial y^2}, \frac{\partial^2 u_n}{\partial z^2} \right).
\end{multline*} 
Для простоты записи можно считать, что система одномерна, т.е. есть всего одно уравнение:
\begin{equation}\label{e1}
\frac{\partial u}{\partial t} = f\left(u, \frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial u}{\partial z}, \frac{\partial^2 u}{\partial x^2}, \frac{\partial^2 u}{\partial y^2}, \frac{\partial^2 u}{\partial z^2}\right).
\end{equation} 
Надо аппроксимировать все производные, стоящие в правой части \eqref{e1}. Нужны аппро\-кси\-ма\-ции для:
\begin{enumerate}
\item центральных функций;
\item функций для рассчета границ блока; \label {i1}
\item функций для рассчета вершин блока (в двумерном и трехмерном случаях);
\item функций для рассчета ребер блока (в трехмерном случае). \label{i2}
\end{enumerate}
В \ref{i1}. - \ref{i2}. надо учитывать краевые условия (в случае краевых условий Неймана как раз и возникает необходимость аппроксимировать производные, а в случае условий Дирихле вместо правой части уравнения \eqref{e1} просто подставляется значение про\-из\-вод\-ной функции, являющейся этим условием), соединения блоков и то, что на разных частях одного блока могут быть заданы разные уравнения. Для приближения про\-из\-вод\-ных во всех функциях используются центральные конечные разности.

Рассмотрим трехмерный блок --- параллелепипед
\begin{equation*}
\Pi = \{(x,y,z) \in R^3| x \in [x_0, x_1], y \in [y_0, y_1], z \in [z_0, z_1]\}.
\end{equation*}
Пусть $m,n,p\in N$ и на $\Pi$ введена сетка с шагами $\Delta x = (x_1-x_0)/m$, $\Delta y = (y_1-y_0)/n$, $\Delta z = (z_1-z_0)/p$ по про\-стран\-ствен\-ным переменным $x,y,z$ и введен шаг $\Delta t$ по времени $t$. Значения функции $u$ в узлах сетки далее обозначаются обычным образом:
\begin{equation*}
u^{\ell}_{ijk} := u(\ell\Delta t, x_0 + i\Delta x, y_0 + j\Delta y, z_0 + k\Delta z),
\end{equation*}
а значения производных в узлах сетки пишутся похожим образом, например:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ijk} := \frac{\partial^2 u}{\partial y^2}(\ell\Delta t, x_0 + i\Delta x, y_0 + j\Delta y, z_0 + k\Delta z).
\end{equation*}
Здесь $\ell = \overline{0,L}$, $i = \overline{0,m}$, $j = \overline{0,n}$, $k = \overline{0,p}$.

{\bf Замечание}: т.к. генератор все-таки умеет генерировать функции для задачи, когда в уравнении есть смешанные производные и при этом рассматриваются блоки без соединений, то для этой ситуации ниже также описаны формулы, используемые генератором для аппроксимации смешанных производных. Для такой задачи урав\-не\-ние \eqref{e1} выглядит по-другому:
\begin{equation}\label{e2}
\frac{\partial u}{\partial t} = f\left(u, \frac{\partial u}{\partial x}, \frac{\partial u}{\partial y}, \frac{\partial u}{\partial z}, \frac{\partial^2 u}{\partial x\partial y}, \frac{\partial^2 u}{\partial x\partial z}, \frac{\partial^2 u}{\partial z\partial y}, \frac{\partial^2 u}{\partial x^2}, \frac{\partial^2 u}{\partial y^2}, \frac{\partial^2 u}{\partial z^2}\right).
\end{equation} 

\subsection{\Large Формулы для производных в центральных функциях}\label{s1}
В центральных функциях для приближения производных используется самый обычный вид конечно-разностных формул.

Первая производная (например, по $z$):
\begin{equation}\label{e3}
\left(\frac{\partial u}{\partial z}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{ijk+1} - u^{\ell}_{ijk-1}}{2\Delta z}
\end{equation}

Вторая чистая производная (например, по $yy$):
\begin{equation}\label{e4}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{ij+1k} - 2u^{\ell}_{ijk} + u^{\ell}_{ij-1k}}{(\Delta y)^2}
\end{equation}

Для центральных функций смешанные производные генерировать очень легко. Смешанная производная (например, по $xz$):
\begin{equation}\label{e5}
\left(\frac{\partial^2 u}{\partial x\partial z}\right)^{\ell}_{ijk} \approx \frac{u^{\ell}_{i+1jk+1} - u^{\ell}_{i-1jk+1} - u^{\ell}_{i+1jk-1} + u^{\ell}_{i-1jk-1}}{4\Delta x\Delta z}
\end{equation}

\subsection{\Large Формулы для производных в функциях рассчета границ блока}\label{s2}
\subsubsection{\large Левая граница}
Рассмотрим, например, границу $y = y_0$ блока. Пусть на каком-то куске \[\Pi_0 = \{(x,y,z) \in \Pi|\quad y = y_0;\quad x_0 \leqslant a \leqslant x \leqslant b \leqslant x_1;\quad z_0 \leqslant c \leqslant z \leqslant d \leqslant z_1\}\] этой границы пользователь задал краевое условие Неймана:
\begin{equation*}
\frac{\partial u}{\partial y}(t,x,y_0,z) = \varphi(t,x,z).
\end{equation*}
И пусть на $\Pi_0$ также задано уравнение \eqref{e2}. Тогда при аппроксимации производных в функциях для рассчета куска $\Pi_0$ используются такие формулы.

Первая производная по $y$:
\begin{equation}\label{e6}
\left(\frac{\partial u}{\partial y}\right)^{\ell}_{i0k} \approx \varphi^{\ell}_{ik} = \varphi(\ell\Delta t, x_0 + i\Delta x, z_0 + k\Delta z),
\end{equation}
а первые производные по $x$ и $z$ будут выглядеть как в \eqref{e3} (т.е. будут центральными).

Вторая производная по $y$:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{i0k} \approx \frac{2\left(u^{\ell}_{i1k} - u^{\ell}_{i0k} - \Delta y  \varphi^{\ell}_{ik}\right)}{(\Delta y)^2},
\end{equation*}
а вторые производные по $x$ и $z$ будут как в \eqref{e4} (т.е. будут центральными).

Смешанная производная по $xy$:
\begin{equation}\label{e7}
\left(\frac{\partial^2 u}{\partial x\partial y}\right)^{\ell}_{i0k} \approx \frac{\varphi^{\ell}_{i+1k} - \varphi^{\ell}_{i-1k}}{2\Delta x};
\end{equation}
смешанная производная по $zy$:
\begin{equation}\label{e8}
\left(\frac{\partial^2 u}{\partial z\partial y}\right)^{\ell}_{i0k} \approx \frac{\varphi^{\ell}_{ik+1} - \varphi^{\ell}_{ik-1}}{2\Delta z};
\end{equation}
смешанная производная по $xz$ будет как в \eqref{e5} (т.е. будет центральной).

Предположим теперь, что область $\Pi_0$ является местом соединения рассматриваемого блока с каким-то другим. Это значит, что на $\Pi_0$ вообще не может быть задано краевых условий. Здесь генератор бессилен при генерировании смешанных производных, поэтому считаем, что на $\Pi_0$ задано уравнение \eqref{e1}. Формулы такие.

Первая производная по $y$:
\begin{equation*}
\left(\frac{\partial u}{\partial y}\right)^{\ell}_{i0k} \approx \frac{u^{\ell}_{i1k} - ic[idx1][idx2]}{2\Delta y},
\end{equation*}
а первые производные по $x$ и $z$ опять будут выглядеть как в \eqref{e3}. Тут $ic$ -- массив интерконнектов, передающийся в рассчетную функцию, а $idx1$ и $idx2$ определяются генератором.

Вторая производная по $y$:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{i0k} \approx \frac{u^{\ell}_{i1k} - 2u^{\ell}_{i0k} +  ic[idx1][idx2]}{(\Delta y)^2},
\end{equation*}
а вторые производные по $x$ и $z$ опять будут как в \eqref{e4}.

Формулы для границ $x = x_0$, $z = z_0$ строятся по аналогии.

\subsubsection{\large Правая граница}
Рассмотрим границу $y = y_1$ блока. Пусть на куске \[\Pi_1 = \{(x,y,z) \in \Pi|\quad y = y_1;\quad x_0 \leqslant A \leqslant x \leqslant B \leqslant x_1;\quad z_0 \leqslant C \leqslant z \leqslant D \leqslant z_1\}\] этой границы пользователь задал краевое условие Неймана:
\begin{equation*}
\frac{\partial u}{\partial y}(t,x,y_1,z) = \psi(t,x,z).
\end{equation*}
И пусть на $\Pi_1$ также задано уравнение \eqref{e2}. Формулы такие.

Для первых производных по $x$, $z$ формулы будут такие же, как в \eqref{e3}, а по $y$ --- как в \eqref{e6} с заменой функции $\varphi$ на $\psi$ и среднего индекса $0$ на $n$ в левой части. Для смешанной производной по $xz$ формула как в \eqref{e5}, а для производных по $xy$ и $zy$ формулы как в \eqref{e7}, \eqref{e8} с заменой функции $\varphi$ на $\psi$ и среднего индекса $0$ на $n$ в левой части.

Сильно изменяется вторая производная по $y$:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ink} \approx \frac{2\left(u^{\ell}_{in-1k} - u^{\ell}_{ink} + \Delta y  \psi^{\ell}_{ik}\right)}{(\Delta y)^2},
\end{equation*}
а вторые производные по $x$ и $z$ опять будут как в \eqref{e4}.

Если область $\Pi_1$ является местом соединения рассматриваемого блока с каким-то другим, то на $\Pi_0$ вообще не может быть задано краевых условий. Считаем, что на $\Pi_1$ задано уравнение \eqref{e1}. Формулы такие.

Первая производная по $y$:
\begin{equation*}
\left(\frac{\partial u}{\partial y}\right)^{\ell}_{ink} \approx \frac{ic[idx1][idx2] - u^{\ell}_{in-1k}}{2\Delta y},
\end{equation*}
а первые производные по $x$ и $z$ опять будут выглядеть как в \eqref{e3}.

Вторая производная по $y$:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y^2}\right)^{\ell}_{ink} \approx \frac{ic[idx1][idx2] - 2u^{\ell}_{ink} + u^{\ell}_{in-1k}}{(\Delta y)^2},
\end{equation*}
а вторые производные по $x$ и $z$ опять будут как в \eqref{e4}.

\subsection{\Large Формулы для производных в функциях рассчета вершин блока (в $2D$ и $3D$) и в функциях рассчета ребер (в $3D$)}

Здесь для производных формулы те же самые, что и в п.~\ref{s1} и \ref{s2}. Отличие только в том, что для гарничных функций производные только по какому-нибудь одному аргументу будут приближены нецентральными формулами, а по всем остальным --- центральными. Здесь же для вершин в двумерном случае производные по обоим аргументам будут приближены нецентральными формулами, а в трехмерном --- по всем трем. Для ребер в $3D$ производные по двум аргументам будут приближены нецентральными формулами, а по третьему аргументу --- центральными.

Особенность только в аппроксимации смешанных производных. Пусть рас\-сма\-три\-ва\-ет\-ся трехмерный блок $\Pi$ (без соединений!) и в окрестности какого-то угла, например, $x = x_0$, $y = y_0$, $z = z_1$ задано уравнение \eqref{e2} и заданы такие условия Неймана на соответствующие границы (можно сразу для простоты считать, что они заданы на каждой из границ полностью, а не на отдельных их частях):
\begin{equation*}
\frac{\partial u}{\partial x}(t,x_0,y,z) = f(t,y,z), \quad \frac{\partial u}{\partial y}(t,x,y_0,z) = g(t,x,z), \quad \frac{\partial u}{\partial z}(t,x,y,z_1) = h(t,x,y).
\end{equation*}

Тогда производные по $xy$, $xz$, $yz$ в рассматриваемой вершине будут ап\-про\-кси\-ми\-ро\-вать\-ся формулами:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial x\partial y}\right)^{\ell}_{00p} \approx \left.\left(\frac{f^{\ell}_{j+1k} - f^{\ell}_{j-1k}}{4\Delta y} + \frac{g^{\ell}_{i+1k} - g^{\ell}_{i-1k}}{4\Delta x}\right)\right|_{i = 0, j = 0, k = p};
\end{equation*}
\begin{equation*}
\left(\frac{\partial^2 u}{\partial x\partial z}\right)^{\ell}_{00p} \approx \left.\left(\frac{f^{\ell}_{jk+1} - f^{\ell}_{jk-1}}{4\Delta z} + \frac{h^{\ell}_{i+1j} - h^{\ell}_{i-1j}}{4\Delta x}\right)\right|_{i = 0, j = 0, k = p};
\end{equation*}
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y\partial z}\right)^{\ell}_{00p} \approx \left.\left(\frac{g^{\ell}_{ik+1} - g^{\ell}_{ik-1}}{4\Delta z} + \frac{h^{\ell}_{ij+1} - h^{\ell}_{ij-1}}{4\Delta y}\right)\right|_{i = 0, j = 0, k = p}.
\end{equation*}
Проблема тут в том, что приходится считать, что нам известны значения функций $f$, $g$ и $h$ за пределами блока $\Pi$.

Формулы для производных на ребрах чуть-чуть отличаются. Ребро --- это место пересечения двух границ. Рассмотрим какое-нибудь ребро, например, $x = x_1$, $z = z_0$. Пусть на соответствующих границах заданы условия Неймана:
\begin{equation*}
\frac{\partial u}{\partial x}(t,x_1,y,z) = \xi(t,y,z), \quad \frac{\partial u}{\partial z}(t,x,y,z_0) = \eta(t,x,y).
\end{equation*}
Тогда формулы для аппроксимации производных на рассматриваемом ребре такие:
\begin{equation*}
\left(\frac{\partial^2 u}{\partial x\partial y}\right)^{\ell}_{mj0} \approx \left.\left(\frac{\xi^{\ell}_{j+1k} - \xi^{\ell}_{j-1k}}{2\Delta y}\right)\right|_{ k = 0};
\end{equation*}
\begin{equation*}
\left(\frac{\partial^2 u}{\partial x\partial z}\right)^{\ell}_{mj0} \approx \left.\left(\frac{\xi^{\ell}_{jk+1} - f^{\ell}_{jk-1}}{4\Delta z} + \frac{\eta^{\ell}_{i+1j} - \eta^{\ell}_{i-1j}}{4\Delta x}\right)\right|_{i = m, k = 0};
\end{equation*}
\begin{equation*}
\left(\frac{\partial^2 u}{\partial y\partial z}\right)^{\ell}_{mj0} \approx \left.\left(\frac{\eta^{\ell}_{ij+1} - \eta^{\ell}_{ij-1}}{4\Delta y}\right)\right|_{i = m}.
\end{equation*}

\end{document}
